# SQL Chatbot with LangChain — Architecture & Component Guide

This document explains **every component** of the Natural Language → SQL Chatbot application and the **architecture** of both the **web** (Streamlit) and **desktop** (Tkinter) versions.

---

## Table of Contents

1. [Overview](#1-overview)
2. [Web Application (Streamlit)](#2-web-application-streamlit)
3. [Desktop Application (Tkinter)](#3-desktop-application-tkinter)
4. [Architecture Diagrams](#4-architecture-diagrams)
5. [Data Flow](#5-data-flow)
6. [External Dependencies](#6-external-dependencies)

---

## 1. Overview

The project provides **two interfaces** to the same core behavior:

| Aspect | Web App (`app.py`) | Desktop App (`desktop_app.py`) |
|--------|--------------------|---------------------------------|
| **Framework** | Streamlit | Tkinter |
| **Run command** | `streamlit run app.py` | `python desktop_app.py` |
| **Database source** | Uploaded `.db` file (copy on server) | Local file via "Open Database" |
| **API key** | `GROQ_API_KEY` from environment | Same |
| **LLM** | Groq (Llama 3.1 8B Instant) | Same |

**Shared behavior (both apps):**

- User uploads/opens a **SQLite** database.
- User types **natural language** (e.g. “Show all employees”, “Delete rows where name is empty”).
- The system **classifies** the query (read vs write vs general chat).
- For database intents: **schema** is read, **SQL** is generated by an **LLM** (Groq).
- **UPDATE/DELETE** are **validated** (e.g. “data exists?”) and **normalized** (case-insensitive, NULL/empty handling).
- **Dangerous** operations (DELETE, DROP, UPDATE) can require **confirmation**.
- **Results** are shown (tables or success messages), and **writes** are committed to the same DB file.

---

## 2. Web Application (Streamlit)

Entry point: **`app.py`**. Run with: `streamlit run app.py`.

### 2.1 Session State

Streamlit is request-based; state is kept in `st.session_state`:

| Key | Purpose |
|-----|--------|
| `history` | List of chat messages (user/assistant) and optional results/dataframes. |
| `db_path` | Path to the **authoritative** DB file for the session (e.g. `user_uploaded.db`). |
| `pending_delete_confirmation` | SQL statement waiting for user confirmation (DELETE/DROP/UPDATE). |
| `delete_confirmation_query` | Original user question that led to that SQL (for display). |

All DB operations use the file at `db_path` only (single source of truth).

### 2.2 Sidebar — Configuration

- **Header:** “Configuration”.
- **API key:** Not asked in UI; app only reads `GROQ_API_KEY` from environment (e.g. `.env`). If missing, a warning can be shown and LLM features are disabled.
- **File uploader:** Accepts `.db`, `.sqlite`, `.sqlite3`. Uploaded file is written to a single path (e.g. `user_uploaded.db`) and that path is stored in `db_path`.

### 2.3 Database Layer

- **`load_database(uploaded_file)`**  
  Writes the uploaded file to disk (e.g. `user_uploaded.db`), sets `st.session_state.db_path`, returns that path. Same file is reused for the whole session.

- **`get_connection()`**  
  Opens a **new** `sqlite3` connection to `st.session_state.db_path` (required). Sets PRAGMAs (e.g. `journal_mode=DELETE`, `synchronous=FULL`, `foreign_keys=ON`). Used for all DB access.

- **`close_connection(conn)`**  
  Safely closes the connection after each use (no long-lived connection).

### 2.4 Schema & Preview

- **`get_schema()`**  
  Reads `sqlite_master` and `PRAGMA table_info` for each user table, builds a text summary (table name, columns, row count). Used as context for the LLM when generating SQL.

- **`get_table_preview(table_name, limit=5)`**  
  Runs `SELECT * FROM table_name LIMIT 5` and returns a pandas DataFrame for the sidebar table preview.

### 2.5 LLM

- **`get_llm()`**  
  Cached with `@st.cache_resource`. If `GROQ_API_KEY` is set, returns a `ChatGroq` instance (e.g. `llama-3.1-8b-instant`, temperature 0). Otherwise returns `None`.

- **`llm`**  
  Single global LLM instance used for classification, SQL generation, and non-SQL answers.

### 2.6 Query Classification

- **`classify_query(query, db_loaded)`**  
  Returns one of: `SQL_READ`, `SQL_WRITE`, `NON_SQL`.
  - If no DB is loaded: only “create database/table” style intents are treated as `SQL_WRITE`; rest are `NON_SQL`.
  - If LLM is available: uses an LLM prompt to classify.
  - Fallback: keyword-based (e.g. “select”, “show” → `SQL_READ`; “insert”, “delete” → `SQL_WRITE`).

### 2.7 SQL Generation

- **`generate_sql(user_query, schema)`**  
  Sends the **schema** and **user request** to the LLM with a “SQLite compiler” style prompt. Response is cleaned (e.g. strip markdown/code fences) and checked to start with a valid keyword (SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, ALTER). Returns a single SQL string.

### 2.8 WHERE Clause Normalization (UPDATE/DELETE)

Used so validation and execution see the **same** logical conditions (case-insensitive, NULL/empty/whitespace).

- **`normalize_where_clause(where_clause)`**  
  Takes the raw WHERE string and:
  - Replaces `column = 'value'` with `LOWER(TRIM(column)) = LOWER(TRIM('value'))`.
  - Treats “null/empty/blank/no value/missing” as `(column IS NULL OR TRIM(column) = '')`.
  - Handles `IS NULL` and `!=`/`<>` similarly.  
  Returns a single canonical WHERE string.

- **`extract_and_normalize_where_clause(sql)`**  
  Parses the SQL to get **table name** and **WHERE** (e.g. for UPDATE/DELETE), then runs `normalize_where_clause` on that WHERE. Returns `(table_name, normalized_where)`.

### 2.9 Validation (UPDATE/DELETE)

- **`validate_modification(sql, conn)`**  
  Only runs for UPDATE/DELETE. Uses `extract_and_normalize_where_clause` and runs:
  - `SELECT COUNT(*) FROM table WHERE <normalized_where>`.
  - If count is 0: returns `(False, "Requested data not found in the database. No changes were made.")`.
  - Otherwise returns `(True, "")`.  
  So confirmation is only asked when at least one row matches.

### 2.10 SQL Execution

- **`execute_sql(sql)`**  
  - Ensures a DB path exists (e.g. creates `user_uploaded.db` for “create DB” flows).
  - For **UPDATE/DELETE**: rebuilds SQL using the **same** normalized WHERE (and for UPDATE, keeps the SET clause) so execution matches validation.
  - For **SELECT**: runs as-is and returns a DataFrame.
  - For **writes**: runs, then `conn.commit()`, then closes. Returns success and row count.

### 2.11 Safety & Confirmation

- **`requires_confirmation(sql)`**  
  Returns True for statements starting with DELETE, DROP, or UPDATE. Used to decide whether to show a confirmation step.

- **Confirmation flow (UI):**  
  When confirmation is required, the generated SQL is stored in `pending_delete_confirmation` and the UI shows “Dangerous Operation” and Yes/Cancel. Only on “Yes” is `execute_sql` called with that SQL.

### 2.12 Non-SQL Queries

- **`handle_non_sql_query(query)`**  
  Sends the user message to the LLM with a general “helpful assistant” prompt. Optionally includes current DB schema in context. Used when `classify_query` returns `NON_SQL`.

### 2.13 Main UI (Web)

- **Sidebar (when DB loaded):**  
  “Database Loaded”, list of tables, table preview dropdown, and **“Download Updated Database”** button that serves the current `db_path` file so the user can save the updated copy.

- **Main area:**  
  - Renders `history` (user/assistant messages, code blocks, dataframes).
  - If `pending_delete_confirmation` is set: shows the dangerous SQL and Yes/Cancel.
  - Chat input: on submit, app classifies → generates SQL (if DB intent) → validates (for UPDATE/DELETE) → asks confirmation if needed → executes and appends to history.

So in the web app, **one** uploaded file is the authority; the user gets changes by **downloading** that file again.

---

## 3. Desktop Application (Tkinter)

Entry point: **`desktop_app.py`**. Run with: `python desktop_app.py`.

### 3.1 Theme

- **`THEME`**  
  Dict of colors and fonts (e.g. dark background, blue accent, bubble colors for user/AI). Used by all Tkinter widgets for a consistent “modern dark” look.

### 3.2 Backend Logic (Same Concepts as Web)

- **`BackendLogic`**  
  Holds `db_path` and encapsulates:

  - **`get_llm()`** — Same as web: Groq with `GROQ_API_KEY` from env.
  - **`set_db_path(path)`** — Sets the DB file path (from file dialog).
  - **`get_connection()`** — Opens sqlite3 to `db_path` with same PRAGMAs.
  - **`get_schema()`** — Same idea as web: tables + columns + row counts as text.
  - **`normalize_where_clause(where_clause)`** — Same normalization rules as web.
  - **`extract_and_normalize_where_clause(sql)`** — Same parsing and normalization.
  - **`validate_modification(sql, conn)`** — Same: `SELECT COUNT(*)` with normalized WHERE; “data not found” if 0.

So the **authority** on the desktop is the **local file** the user opened; all operations read/write that file.

### 3.3 UI Components

- **`ChatMessage(parent, role, text)`**  
  A frame with a styled label (bubble) for one message. `role` is "User" or "AI"; alignment and color differ by role.

- **`ResultTable(parent, dataframe)`**  
  A frame with a `ttk.Treeview` and scrollbars to show a pandas DataFrame. Used to display SELECT results.

### 3.4 Main Window: `ModernSQLChatbot(tk.Tk)`

- **Layout:**
  - **Left sidebar:** Title, “DATABASE” section (status label, “Open Database” button), short info text at bottom.
  - **Right:** Scrollable canvas containing the chat (messages + tables).
  - **Bottom:** Entry widget + Send button.

- **`select_db()`**  
  Opens a file dialog for `.db`/`.sqlite`, calls `backend.set_db_path(path)`, updates status label, adds a system message.

- **`add_user_message(text)` / `add_ai_message(text)` / `add_system_message(text)`**  
  Append one message to the scrollable area and scroll to bottom.

- **`add_table_result(df)`**  
  Appends a “Result (N rows):” label and a `ResultTable` with the given DataFrame.

- **`on_send()`**  
  Reads the input, clears it, adds user message, and starts **`process_query_thread(query)`** in a **background thread** so the UI stays responsive.

### 3.5 Query Processing (Desktop)

- **`process_query_thread(query)`**  
  - If no DB: suggests opening one (or creating `mydb.db` for “create database”).
  - **Classification:** Keyword-based (e.g. “select”, “insert”, “update” → SQL path; else general chat).
  - **SQL path:**  
    - Gets schema, calls LLM to generate SQL (same style prompt as web).  
    - Validates with `validate_modification`. If invalid, shows “data not found” and returns.  
    - If DELETE/DROP/UPDATE: calls **`ask_confirmation(sql, conn)`** on the main thread (via `self.after`); execution happens in the confirmation callback.  
    - Otherwise: calls **`execute_and_show(sql, conn)`** directly.
  - **General chat:** LLM reply shown as AI message.

- **`ask_confirmation(sql, conn)`**  
  Opens a `messagebox.askyesno`. On Yes, calls `execute_and_show(sql, conn)`; on No, adds “Action cancelled.” Closes `conn` after.

- **`execute_and_show(sql, conn)`**  
  - For UPDATE/DELETE: rebuilds SQL with **same** normalized WHERE (same logic as web).
  - Executes; for SELECT fetches rows and shows via `add_table_result`; for writes commits and shows success + row count. Uses `self.after(0, ...)` to update UI from the worker thread.

So on desktop, **one** local file is the authority; there is no “upload copy” — the app writes directly to the chosen file.

---

## 4. Architecture Diagrams

### 4.1 Web Application (Streamlit) — High-Level

```text
┌─────────────────────────────────────────────────────────────────────────────┐
│                           STREAMLIT WEB APP (app.py)                          │
├─────────────────────────────────────────────────────────────────────────────┤
│  BROWSER                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Sidebar              │  Main Area                                    │   │
│  │  • Config             │  • Chat history (user / assistant)             │   │
│  │  • DB Upload          │  • Code blocks (generated SQL)                │   │
│  │  • Tables + Preview   │  • DataFrames (SELECT results)                 │   │
│  │  • Download DB        │  • Confirmation (Yes/Cancel) for dangerous SQL │   │
│  │                       │  • Chat input                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  SESSION STATE (st.session_state)                                             │
│  • history, db_path, pending_delete_confirmation, delete_confirmation_query   │
└─────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  APPLICATION LAYER                                                           │
│  • load_database / get_connection / close_connection                          │
│  • get_schema / get_table_preview                                            │
│  • get_llm (cached)                                                          │
│  • classify_query → SQL_READ | SQL_WRITE | NON_SQL                           │
│  • generate_sql(schema + user_query)                                         │
│  • normalize_where_clause / extract_and_normalize_where_clause               │
│  • validate_modification (COUNT with normalized WHERE)                        │
│  • execute_sql (normalized WHERE for UPDATE/DELETE, commit for writes)        │
│  • requires_confirmation / handle_non_sql_query                               │
└─────────────────────────────────────────────────────────────────────────────┘
                                        │
                    ┌───────────────────┼───────────────────┐
                    ▼                   ▼                   ▼
            ┌───────────────┐   ┌───────────────┐   ┌───────────────┐
            │  SQLite       │   │  Groq API     │   │  .env         │
            │  (file at     │   │  (LLM)        │   │  GROQ_API_KEY  │
            │  db_path)     │   │               │   │               │
            └───────────────┘   └───────────────┘   └───────────────┘
```

### 4.2 Web Application — Request Flow (User Sends a Message)

```text
User types message
        │
        ▼
┌───────────────────┐
│ classify_query    │ ──► NON_SQL ──► handle_non_sql_query ──► Show LLM reply
└───────────────────┘
        │
        │ SQL_READ | SQL_WRITE
        ▼
┌───────────────────┐
│ get_schema        │
└───────────────────┘
        │
        ▼
┌───────────────────┐
│ generate_sql      │ (LLM)
└───────────────────┘
        │
        ▼
┌───────────────────────────────────────┐
│ UPDATE/DELETE? → validate_modification │
│ (SELECT COUNT(*) + normalized WHERE)  │
└───────────────────────────────────────┘
        │
        ├── 0 rows ──► "Requested data not found" (no confirmation, no execution)
        │
        └── ≥1 row ──► requires_confirmation?
                        │
                        ├── Yes ──► Store SQL, show Yes/Cancel ──► On Yes: execute_sql
                        │
                        └── No ──► execute_sql (normalized WHERE, commit)
                                        │
                                        ▼
                                Show result (table or success message)
```

### 4.3 Desktop Application (Tkinter) — High-Level

```text
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DESKTOP APP (desktop_app.py)                               │
├─────────────────────────────────────────────────────────────────────────────┤
│  TKINTER WINDOW (ModernSQLChatbot)                                           │
│  ┌────────────────────┬──────────────────────────────────────────────────┐  │
│  │  SIDEBAR           │  MAIN CONTENT                                     │  │
│  │  • Title           │  • Scrollable canvas → scrollable_frame           │  │
│  │  • DATABASE        │    • ChatMessage (User / AI)                      │  │
│  │    - Status        │    • ResultTable (DataFrame)                     │  │
│  │    - Open DB       │    • System messages                             │  │
│  │  • Info text       │  • Input: Entry + Send button                    │  │
│  └────────────────────┴──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  BackendLogic                                                               │
│  • db_path, get_llm, set_db_path, get_connection, get_schema                │
│  • normalize_where_clause, extract_and_normalize_where_clause               │
│  • validate_modification                                                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                        │
                    ┌───────────────────┼───────────────────┐
                    ▼                   ▼                   ▼
            ┌───────────────┐   ┌───────────────┐   ┌───────────────┐
            │  SQLite       │   │  Groq API      │   │  .env          │
            │  (local file  │   │  (LLM)         │   │  GROQ_API_KEY  │
            │  from dialog) │   │                │   │                │
            └───────────────┘   └───────────────┘   └───────────────┘
```

### 4.4 Desktop Application — Message Flow

```text
User clicks Send / Enter
        │
        ▼
on_send() → add_user_message → process_query_thread (in background thread)
        │
        ▼
No DB? → Show "Open database" / "create mydb.db" and return
        │
        ▼
Keyword classification (SQL vs general)
        │
        ├── General ──► LLM reply ──► add_ai_message (via self.after)
        │
        └── SQL ──► get_schema → LLM → SQL
                          │
                          ▼
                    validate_modification
                          │
                          ├── Invalid ──► add_ai_message("data not found")
                          │
                          └── Valid ──► DELETE/DROP/UPDATE?
                                        │
                                        ├── Yes ──► ask_confirmation (main thread)
                                        │              │
                                        │              └── Yes ──► execute_and_show
                                        │
                                        └── No ──► execute_and_show
                                                          │
                                                          ▼
                                            execute_and_show:
                                            • Normalize WHERE (same as web)
                                            • cursor.execute / commit
                                            • add_table_result or add_ai_message (via self.after)
```

---

## 5. Data Flow

### 5.1 Single Source of Truth (DB File)

| App    | Authority DB file |
|--------|--------------------|
| **Web**   | Uploaded file is copied to one path (e.g. `user_uploaded.db`). All reads/writes use that file. User gets updates by **downloading** that file. |
| **Desktop** | User selects one local file via “Open Database”. All reads/writes go to that file. No upload/download. |

### 5.2 End-to-End (Example: “Delete employees named John”)

1. **Input:** Natural language string.
2. **Classification:** SQL_WRITE (web: LLM or keywords; desktop: keywords).
3. **Schema:** Read from DB and passed to LLM.
4. **SQL generation:** LLM returns e.g. `DELETE FROM EMPLOYEE WHERE FIRST_NAME = 'John'`.
5. **Normalization:** WHERE becomes e.g. `LOWER(TRIM(FIRST_NAME)) = LOWER(TRIM('John'))`.
6. **Validation:** `SELECT COUNT(*) FROM EMPLOYEE WHERE <normalized WHERE>`.
   - 0 → “Requested data not found”, stop.
   - ≥1 → Continue.
7. **Confirmation:** (If app requires it) show SQL and Yes/Cancel.
8. **Execution:** Run DELETE with the **same** normalized WHERE; `commit()`; close connection.
9. **Output:** Success message (and on web, “Download Updated Database” still points to same file).

---

## 6. External Dependencies

| Dependency | Role |
|------------|------|
| **streamlit** | Web UI, session state, widgets, rerun. |
| **tkinter** | Desktop UI (usually bundled with Python). |
| **langchain_groq** | `ChatGroq` for LLM calls (classification, SQL generation, non-SQL chat). |
| **python-dotenv** | Loads `.env` (e.g. `GROQ_API_KEY`). |
| **pandas** | DataFrames for SELECT results and table preview. |
| **sqlite3** | Standard library; DB connection and execution. |

Optional / other files:

- **sqlite.py** — Standalone script (e.g. CSV → SQLite); not required by `app.py` or `desktop_app.py`.
- **main.py** — Placeholder entry point; not the main app.
- **check_models.py** — Gemini test; separate from the SQL chatbot.

---

## Summary

- **Web (`app.py`):** Streamlit UI, session state, single uploaded DB copy as authority, LLM classification + SQL generation, normalized WHERE for validation/execution, confirmation for dangerous SQL, download for updated DB.
- **Desktop (`desktop_app.py`):** Tkinter UI, same backend ideas in `BackendLogic`, local DB file as authority, threading for non-blocking queries, confirmation via message box, same normalization and validation rules.

Both applications share the same **logical flow**: classify → schema → generate SQL → validate (for UPDATE/DELETE) → confirm (if required) → execute with normalized WHERE and commit.
